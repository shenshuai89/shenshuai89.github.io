---
title: 网络协议TCP/UDP
date: 2020-05-23 21:57:03
tags: 
  - 网络协议
  - TCP UDP
  - HTTP
permalink: /pages/8e8d4e/
author: 
  name: 北鸟南游
  link: https://shenshuai89.github.io/
---

## 网络传输模式

7层网络模型OSI

![](/assets/images/OSI.png)

1. 基础层：Physical物理层、DataLink数据链路层、Network网络层
2. 传输层：Transport传输层，主要包含TCP/UDP协议层
3. 高级层：Session会话层、Presentation表现层、Application应用层



### TCP

TCP（Transmission Control Protocol）是面向连接的通信协议，是一种可靠的基于字节流的传输层通信协议，由IETF的RFC 793定义。通过三次握手建立连接，通信完成时通过四次挥手断开连接。由于TCP是面向连接的，所以只能用于端到端的通讯

TCP机制

1. 三次握手、四次挥手
2. 具有校验机制、可靠、数据传输稳定

#### 连接可靠性-三次握手，而不是两次或者四次握手
![](/assets/images/sanciwoshou)

TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。

起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。 
服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。

**第一次握手** 
客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。

- PS1：SYN=1，ACK=0表示该报文段为连接请求报文。
- PS2：x为本次TCP通信的字节流的初始序号。 
  TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。

**第二次握手** 
服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。 
该应答发送完成后便进入SYN-RCVD状态。

- PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。
- PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。
- PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。

**第三次握手** 
当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。 
该报文段的头部为：ACK=1，seq=x+1，ack=y+1。 
客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！

**为什么连接建立需要三次握手，而不是两次握手？** 
防止失效的连接请求报文段被服务端接收，从而产生错误。

PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。

若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。


#### 断开连接，四次挥手
![](/assets/images/sicihuishou)

TCP连接的释放一共需要四步，因此称为『四次挥手』。 
我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。

**第一次挥手** 
若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为： 
FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。

- PS1：FIN=1表示该报文段是一个连接释放请求。
- PS2：seq=u，u-1是A向B发送的最后一个字节的序号。

**第二次挥手** 
B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含： 
ACK=1，seq=v，ack=u+1。

- PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。
- PS2：seq=v，v-1是B向A发送的最后一个字节的序号。
- PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。

A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。

第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。

**第三次挥手** 
当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。

**第四次挥手** 
A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。

**为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？** 
为了保证B能收到A的确认应答。 
若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。

链接：https://www.zhihu.com/question/24853633/answer/254224088


### UDP

UDP（user Datagram Protocol）是用户数据报文协议，面向无连接的通讯协议，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。UDP数据包括目的的端口号和源端口信息。
