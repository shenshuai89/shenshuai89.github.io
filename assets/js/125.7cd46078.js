(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{440:function(a,t,r){"use strict";r.r(t);var v=r(7),s=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"java-并发编程实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-并发编程实战"}},[a._v("#")]),a._v(" Java 并发编程实战")]),a._v(" "),t("blockquote",[t("p",[a._v("全面系统提升你的并发编程能力\n王宝令 资深架构师")])]),a._v(" "),t("p",[a._v("你将获得")]),a._v(" "),t("ul",[t("li",[a._v("全面了解并发编程核心原理；")]),a._v(" "),t("li",[a._v("深入掌握 12 个 Java 并发工具类；")]),a._v(" "),t("li",[a._v("搞懂 9 种最常见的并发设计模式；")]),a._v(" "),t("li",[a._v("4 大经典并发编程实战案例。")])]),a._v(" "),t("h3",{attrs:{id:"课程介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#课程介绍"}},[a._v("#")]),a._v(" 课程介绍")]),a._v(" "),t("p",[a._v("对于一个 Java 程序员而言，能否熟练掌握并发编程是判断他优秀与否的重要标准之一。因为并发编程是 Java 语言中最为晦涩的知识点，它涉及操作系统、内存、CPU、编程语言等多方面的基础能力，更为考验一个程序员的内功。")]),a._v(" "),t("p",[a._v("那到底应该怎么学习并发编程呢？Java SDK 的并发工具包有很多，是要死记硬背每一个工具的优缺点和使用场景吗？当然不是，想要学好并发编程，你需要从一个个单一的知识和技术中“跳出来”，高屋建瓴地看问题，并逐步建立自己的知识体系。")]),a._v(" "),t("p",[a._v("本专栏希望能够帮助你建立起一张处理并发问题的全景图，让你能够彻底理解并发问题的本质所在。同时，专栏还会深入介绍 Java 并发编程技术背后的逻辑关系以及应用场景，助你能够游刃有余地游走在这些技术之中。")]),a._v(" "),t("h3",{attrs:{id:"课程设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#课程设计"}},[a._v("#")]),a._v(" 课程设计")]),a._v(" "),t("h4",{attrs:{id:"整个专栏分为-5-个模块。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整个专栏分为-5-个模块。"}},[a._v("#")]),a._v(" 整个专栏分为 5 个模块。")]),a._v(" "),t("h4",{attrs:{id:"并发理论基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发理论基础"}},[a._v("#")]),a._v(" 并发理论基础")]),a._v(" "),t("ul",[t("li",[a._v("这个模块主要介绍并发编程相关的概念和理论。但不会死板地堆叠结论，而是关注具体概念和理论的产生背景，挖掘它们背后的逻辑关系，发现核心矛盾并寻找解决方案。比如，深度认识 Java 内存模型、死锁产生的原因和解决方案、线程间的协作机制，等等。")])]),a._v(" "),t("h4",{attrs:{id:"并发工具类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发工具类"}},[a._v("#")]),a._v(" 并发工具类")]),a._v(" "),t("ul",[t("li",[a._v("这个模块主要探讨 Java SDK 里的并发工具类。这些工具类大部分都是基于管程实现的，所以这里会首先介绍隐藏在并发包中的管程及其使用。紧接着还会为你详细解读信号量、读写锁、CountDownLatch 和 CyclicBarrier，以及并发编程的三个核心问题“分工”“同步”“互斥”相关的技术内容。")])]),a._v(" "),t("h4",{attrs:{id:"并发设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发设计模式"}},[a._v("#")]),a._v(" 并发设计模式")]),a._v(" "),t("ul",[t("li",[a._v("并发设计模式是解决并发问题的最佳实践。这个模块将会介绍 9 种常见的设计模式。其中，前 3 种设计模式的核心思想是避免共享变量，从而避免并发问题；后面 6 种设计模式则都属于典型的分工模式。")])]),a._v(" "),t("h4",{attrs:{id:"案例分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#案例分析"}},[a._v("#")]),a._v(" 案例分析")]),a._v(" "),t("ul",[t("li",[a._v("这个模块着重分析 4 个经典的开源框架是如何处理并发问题的，包括高性能限流器 Guava RateLimiter、高性能网络应用框架 Netty、高性能队列 Disruptor、高性能数据库连接池 HiKariCP，希望能够帮你融会贯通相关知识点，并从实战场景中思考问题的最优解。")])]),a._v(" "),t("h4",{attrs:{id:"其他并发模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他并发模型"}},[a._v("#")]),a._v(" 其他并发模型")]),a._v(" "),t("ul",[t("li",[a._v("并发问题是一个通用问题，Java 语言解决并发问题采用的是共享内存模型，但这个模型并不是解决并发问题唯一的模型。这个模块将会介绍共享内存模型之外的模型，主要有 Actor 模型、软件事务内存、协程和 CSP 模型。")])]),a._v(" "),t("p",[t("a",{attrs:{href:"https://pan.baidu.com/s/1gSbmoewCSiddn1fV2m6W8w",target:"_blank",rel:"noopener noreferrer"}},[a._v("资源下载"),t("OutboundLink")],1),a._v("提取码：http://dt2.8tupian.net/2/29369a54b200.pg1")])])}),[],!1,null,null,null);t.default=s.exports}}]);