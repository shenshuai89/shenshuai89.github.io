(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{374:function(v,_,s){"use strict";s.r(_);var t=s(7),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"网络传输模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络传输模式"}},[v._v("#")]),v._v(" 网络传输模式")]),v._v(" "),_("p",[v._v("7层网络模型OSI")]),v._v(" "),_("p",[_("img",{attrs:{src:"/assets/images/OSI.png",alt:""}})]),v._v(" "),_("ol",[_("li",[v._v("基础层：Physical物理层、DataLink数据链路层、Network网络层")]),v._v(" "),_("li",[v._v("传输层：Transport传输层，主要包含TCP/UDP协议层")]),v._v(" "),_("li",[v._v("高级层：Session会话层、Presentation表现层、Application应用层")])]),v._v(" "),_("h3",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),_("p",[v._v("TCP（Transmission Control Protocol）是面向连接的通信协议，是一种可靠的基于字节流的传输层通信协议，由IETF的RFC 793定义。通过三次握手建立连接，通信完成时通过四次挥手断开连接。由于TCP是面向连接的，所以只能用于端到端的通讯")]),v._v(" "),_("p",[v._v("TCP机制")]),v._v(" "),_("ol",[_("li",[v._v("三次握手、四次挥手")]),v._v(" "),_("li",[v._v("具有校验机制、可靠、数据传输稳定")])]),v._v(" "),_("h4",{attrs:{id:"连接可靠性-三次握手-而不是两次或者四次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连接可靠性-三次握手-而不是两次或者四次握手"}},[v._v("#")]),v._v(" 连接可靠性-三次握手，而不是两次或者四次握手")]),v._v(" "),_("p",[_("img",{attrs:{src:"/assets/images/sanciwoshou",alt:""}})]),v._v(" "),_("p",[v._v("TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。")]),v._v(" "),_("p",[v._v("起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。\n服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。")]),v._v(" "),_("p",[_("strong",[v._v("第一次握手")]),v._v("\n客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。")]),v._v(" "),_("ul",[_("li",[v._v("PS1：SYN=1，ACK=0表示该报文段为连接请求报文。")]),v._v(" "),_("li",[v._v("PS2：x为本次TCP通信的字节流的初始序号。\nTCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。")])]),v._v(" "),_("p",[_("strong",[v._v("第二次握手")]),v._v("\n服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。\n该应答发送完成后便进入SYN-RCVD状态。")]),v._v(" "),_("ul",[_("li",[v._v("PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。")]),v._v(" "),_("li",[v._v("PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。")]),v._v(" "),_("li",[v._v("PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。")])]),v._v(" "),_("p",[_("strong",[v._v("第三次握手")]),v._v("\n当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。\n该报文段的头部为：ACK=1，seq=x+1，ack=y+1。\n客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！")]),v._v(" "),_("p",[_("strong",[v._v("为什么连接建立需要三次握手，而不是两次握手？")]),v._v("\n防止失效的连接请求报文段被服务端接收，从而产生错误。")]),v._v(" "),_("p",[v._v("PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。")]),v._v(" "),_("p",[v._v("若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。")]),v._v(" "),_("h4",{attrs:{id:"断开连接-四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#断开连接-四次挥手"}},[v._v("#")]),v._v(" 断开连接，四次挥手")]),v._v(" "),_("p",[_("img",{attrs:{src:"/assets/images/sicihuishou",alt:""}})]),v._v(" "),_("p",[v._v("TCP连接的释放一共需要四步，因此称为『四次挥手』。\n我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。")]),v._v(" "),_("p",[_("strong",[v._v("第一次挥手")]),v._v("\n若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：\nFIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。")]),v._v(" "),_("ul",[_("li",[v._v("PS1：FIN=1表示该报文段是一个连接释放请求。")]),v._v(" "),_("li",[v._v("PS2：seq=u，u-1是A向B发送的最后一个字节的序号。")])]),v._v(" "),_("p",[_("strong",[v._v("第二次挥手")]),v._v("\nB收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：\nACK=1，seq=v，ack=u+1。")]),v._v(" "),_("ul",[_("li",[v._v("PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。")]),v._v(" "),_("li",[v._v("PS2：seq=v，v-1是B向A发送的最后一个字节的序号。")]),v._v(" "),_("li",[v._v("PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。")])]),v._v(" "),_("p",[v._v("A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。")]),v._v(" "),_("p",[v._v("第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。")]),v._v(" "),_("p",[_("strong",[v._v("第三次挥手")]),v._v("\n当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。")]),v._v(" "),_("p",[_("strong",[v._v("第四次挥手")]),v._v("\nA收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。")]),v._v(" "),_("p",[_("strong",[v._v("为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？")]),v._v("\n为了保证B能收到A的确认应答。\n若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。")]),v._v(" "),_("p",[v._v("链接：https://www.zhihu.com/question/24853633/answer/254224088")]),v._v(" "),_("h3",{attrs:{id:"udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[v._v("#")]),v._v(" UDP")]),v._v(" "),_("p",[v._v("UDP（user Datagram Protocol）是用户数据报文协议，面向无连接的通讯协议，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。UDP数据包括目的的端口号和源端口信息。")])])}),[],!1,null,null,null);_.default=a.exports}}]);