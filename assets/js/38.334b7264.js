(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{353:function(t,e,s){"use strict";s.r(e);var a=s(7),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("原文链接："),e("a",{attrs:{href:"https://nextjs.org/learn/dashboard-app/partial-prerendering",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://nextjs.org/learn/dashboard-app/partial-prerendering"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("到目前为止，您已经了解了静态和动态渲染，以及如何流式传输依赖于数据的动态内容。在本章中，让我们学习如何将静态渲染、动态渲染和流在同一路径中与**部分预渲染（PPR）**相结合。")]),t._v(" "),e("blockquote",[e("p",[t._v("部分预渲染是Next.js 14中引入的一个实验功能。此页面的内容可能会随着功能的稳定性而更新。")])]),t._v(" "),e("h2",{attrs:{id:"本章目标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本章目标"}},[t._v("#")]),t._v(" 本章目标：")]),t._v(" "),e("ul",[e("li",[t._v("什么是部分预渲染。")]),t._v(" "),e("li",[t._v("部分预渲染的工作原理。")])]),t._v(" "),e("blockquote",[e("p",[t._v("翻译时添加-本章是实验性质属性，可以不修改。")])]),t._v(" "),e("h2",{attrs:{id:"静态与动态路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态与动态路由"}},[t._v("#")]),t._v(" 静态与动态路由")]),t._v(" "),e("p",[t._v("对于目前构建的大多数web应用程序，您可以在整个应用程序的静态和动态渲染之间进行选择，或者用于特定路由。在Next.js中，如果您在路由中调用动态函数（如查询数据库），整个路由变得动态。\n然而，大多数路由并不是完全静态或动态的。例如，思考下 "),e("a",{attrs:{href:"https://partialprerendering.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ecommerce site"),e("OutboundLink")],1),t._v(" 这个网站，您可能希望静态呈现大部分产品信息页面，您可能想要动态地获取用户的购物车和推荐的产品，这允许您向用户显示个性化内容。\n返回到您的仪表板页面，你认为哪些应该是静态或动态的组件？\n准备好后，查看我们将如何拆分仪表板路线：\n"),e("img",{attrs:{src:"/assets/images/nextjs/10-1image.png",alt:"image.png"}})]),t._v(" "),e("ul",[e("li",[e("code",[t._v("<SideNav>")]),t._v("组件不依赖数据，也不针对用户进行个性化设置，因此它可以是静态的。")]),t._v(" "),e("li",[e("code",[t._v("＜Page＞")]),t._v("中的组件依赖于经常更改的数据，这些数据将针对用户进行个性化设置，因此它们可以是动态的。")])]),t._v(" "),e("h2",{attrs:{id:"什么是部分预渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是部分预渲染"}},[t._v("#")]),t._v(" 什么是部分预渲染")]),t._v(" "),e("p",[t._v("Next.js 14引入了Partial Prerendering的实验版本。一个新的渲染模型，允许您在同一路由中结合静态和动态渲染的优点。例如：\n"),e("img",{attrs:{src:"/assets/images/nextjs/10-2image.png",alt:"image.png"}}),t._v("\n当用户访问路由时")]),t._v(" "),e("ul",[e("li",[t._v("提供包括导航栏和产品信息的静态路由外壳，确保快速的初始加载。")]),t._v(" "),e("li",[t._v("外壳留下了一些插槽，其中动态内容（如购物车和推荐产品）将异步加载。")]),t._v(" "),e("li",[t._v("异步并行传输，减少了页面的总体加载时间。")])]),t._v(" "),e("h2",{attrs:{id:"部分预渲染是如何工作的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#部分预渲染是如何工作的"}},[t._v("#")]),t._v(" 部分预渲染是如何工作的")]),t._v(" "),e("p",[t._v("部分预渲染使用使用react "),e("a",{attrs:{href:"https://react.dev/reference/react/Suspense",target:"_blank",rel:"noopener noreferrer"}},[t._v("Suspense"),e("OutboundLink")],1),t._v(" （在上一章中了解到的）推迟呈现应用程序的部分，直到满足某些条件。\nSuspense fallback与静态内容一起嵌入到初始HTML文件中。在构建时（或在重新验证期间），静态内容被预先呈现以创建静态外壳。动态内容的呈现被推迟，直到用户请求路由为止。\n在Suspense中封装组件不会使组件本身成为动态的，而是将Suspense用作静态代码和动态代码之间的边界。\n我们看看如何在仪表板路由中实现PPR。")]),t._v(" "),e("h2",{attrs:{id:"实现部分预渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现部分预渲染"}},[t._v("#")]),t._v(" 实现部分预渲染")]),t._v(" "),e("p",[t._v("通过添加"),e("a",{attrs:{href:"https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr",target:"_blank",rel:"noopener noreferrer"}},[t._v("ppr"),e("OutboundLink")],1),t._v("配置，在"),e("code",[t._v("next.config.mjs")]),t._v("文件中。")]),t._v(" "),e("div",{staticClass:"language-tsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-tsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** @type {import('next').NextConfig} */")]),t._v("\n \n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" nextConfig "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  experimental"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    ppr"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'incremental'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \nmodule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nextConfig"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[t._v("“incremental”值允许您对特定路线采用PPR。\n接下来，将experiental_ppr segment config选项添加到仪表板布局中：")]),t._v(" "),e("div",{staticClass:"language-tsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-tsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" SideNav "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@/app/ui/dashboard/sidenav'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" experimental_ppr "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("p",[t._v("就是这样。在开发过程中，您可能看不到应用程序有什么不同，但在生产过程中您应该注意到性能的提高。Next.js将预先呈现路由的静态部分，并将动态部分推迟到用户请求。\nPartial Prerendering的好处在于，您不需要更改代码即可使用它。只要您使用Suspense来包装路由的动态部分，Next.js就会知道路由的哪些部分是静态的，哪些是动态的。\n我们相信PPR有可能成为web"),e("a",{attrs:{href:"https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model",target:"_blank",rel:"noopener noreferrer"}},[t._v("应用程序的默认渲染模型"),e("OutboundLink")],1),t._v("，将静态网站和动态渲染的最佳效果结合在一起。然而，它仍然是实验性的。我们希望在未来稳定它，并使其成为Next.js的默认构建方式。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结：")]),t._v(" "),e("p",[t._v("回顾一下，您已经做了一些事情来优化应用程序中的数据获取：")]),t._v(" "),e("ol",[e("li",[t._v("在与您的应用程序代码相同的区域创建数据库，以减少服务器和数据库之间的延迟。")]),t._v(" "),e("li",[t._v("使用 React Server Components 在服务器上获取数据。这允许您在服务器上保留昂贵的数据获取和逻辑，减少客户端 JavaScript 包，并防止您的数据库机密暴露给客户端。")]),t._v(" "),e("li",[t._v("使用 SQL 仅获取您需要的数据，从而减少每次请求传输的数据量和在内存中转换数据所需的 JavaScript 量。")]),t._v(" "),e("li",[t._v("使用 JavaScript 并行获取数据——这样做是有意义的。")]),t._v(" "),e("li",[t._v("实现流式传输以防止缓慢的数据请求阻塞整个页面，并允许用户开始与 UI 交互而无需等待所有内容加载。")]),t._v(" "),e("li",[t._v("将数据获取移至需要它的组件，从而隔离路线的哪些部分应该是动态的。")])]),t._v(" "),e("p",[t._v("在下一章中，我们将介绍获取数据时可能需要实现的两种常见模式：搜索和分页。")])])}),[],!1,null,null,null);e.default=n.exports}}]);